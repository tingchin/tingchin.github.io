<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAA-OS2024-Lab1-实验报告</title>
      <link href="/2024/04/07/buaa-os2024-lab1-shi-yan-bao-gao/"/>
      <url>/2024/04/07/buaa-os2024-lab1-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h3><blockquote><p>请阅读 附录中的编译链接详解，尝试分别使用实验环境中的原生 x86 工具链（gcc、ld、readelf、objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c              <span class="comment"># 原生X86生成.o文件</span></span><br><span class="line">gcc hello.o                 <span class="comment"># 原生x86链接</span></span><br><span class="line">readelf -h hello.o          <span class="comment"># 读elf文件头</span></span><br><span class="line">objdump -DS hello.o &gt; h.txt <span class="comment"># 反汇编</span></span><br><span class="line"></span><br><span class="line">mips-linux-gnu-gcc -c hello.c              <span class="comment"># 生成.o文件</span></span><br><span class="line">mips-linux-gnu-gcc hello.o                 <span class="comment"># 链接</span></span><br><span class="line">mips-linux-gnu-readelf -h hello.o          <span class="comment"># 读elf文件头</span></span><br><span class="line">mips-linux-gnu-objdump -DS hello.o &gt; h.txt <span class="comment"># 反汇编</span></span><br></pre></td></tr></table></figure><p><strong>两种工具的一些区别</strong></p><ul><li>原生x86汇编的是elf64文件  交叉汇编的是elf32文件</li><li>原生x86汇编的是小端文件，交叉汇编的是大端文件</li><li>两边反汇编出来的源码分别是X86和MIPS的源码</li></ul><p><strong>一些特点</strong></p><ul><li>.o文件时，调用函数地址为0</li><li>生成可执行文件后，才能重定位，找到正确的地址</li></ul><p><strong>objdump参数含义：</strong></p><ul><li>-D 反汇编所有section的信息</li><li>-S 尽可能反汇编出源代码</li></ul><h3 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h3><blockquote><p>思考下述问题：</p><p> 尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文件。</p><p>也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚才介绍的系&gt;统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf-h，并阅读 tools&#x2F;readelf 目录下的 Makefile，观察 readelf 与 hello 的不同）</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">git@22371218:~/22371218/target (lab1)$ ~/22371218/tools/readelf/readelf mos</span><br><span class="line">0:0x0</span><br><span class="line">1:0x80020000</span><br><span class="line">2:0x800218d0</span><br><span class="line">3:0x800218e8</span><br><span class="line">4:0x80021900</span><br><span class="line">5:0x0</span><br><span class="line">6:0x0</span><br><span class="line">7:0x0</span><br><span class="line">8:0x0</span><br><span class="line">9:0x0</span><br><span class="line">10:0x0</span><br><span class="line">11:0x0</span><br><span class="line">12:0x0</span><br><span class="line">13:0x0</span><br><span class="line">14:0x0</span><br><span class="line">15:0x0</span><br><span class="line">16:0x0</span><br></pre></td></tr></table></figure><p>我们定义的<code>ELF</code> 格式是32位，也就是说，我们自己编写的<code>readelf</code> 程序只能阅读32位的ELF文件。</p><p>通过<code>readelf -h hello</code> 和<code>readelf -h mos</code> ，发现他们都是ELf32的文件，因此可以用我们编写的<code>readelf</code>阅读。而我们编写的<code>readelf</code> 是ELF64的文件，是64位的，所以无法解析。</p><p>观察readelf目录下的Makefile文件，可以知道，我们的<code>readelf</code>是<code>$(CC) $^ -o $@</code>编译的64位文件，而<code>hello</code> 是通过<code> $(CC) $^ -o $@ -m32 -static -g</code> 编译的，通过<code>-m32</code> 参数生成的是32位文件。</p><h3 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h3><blockquote><p>在理论课上我们了解到，MIPS 体系结构上电时，启动入口地0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？</p></blockquote><p>我们的mos是运行在在QEMU上的。QEMU已经提供了bootloader功能，第一步已经完成了。只需要将内核加载后跳转到内核函数入口就可以启动完毕。</p><p>在链接器中，我们指定了内核加载的地址，并通过<code>start</code>中的代码，初始化硬件设备，设置堆栈入口，然后跳转到了内核函数入口处。</p><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><h3 id="1-ELF文件解析"><a href="#1-ELF文件解析" class="headerlink" title="1.ELF文件解析"></a>1.ELF文件解析</h3><p><img src="/2024/04/07/buaa-os2024-lab1-shi-yan-bao-gao/elf.png" alt="elf"></p><p>ELF文件有五个部分：ELF头，段头表，节头表，段表项，节表项</p><p><strong>ELF头</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT]; <span class="comment">/* Magic number and other info */</span></span><br><span class="line">Elf32_Half e_type;  <span class="comment">/* Object file type */</span></span><br><span class="line">Elf32_Half e_machine;  <span class="comment">/* Architecture */</span></span><br><span class="line">Elf32_Word e_version;  <span class="comment">/* Object file version */</span></span><br><span class="line">Elf32_Addr e_entry;  <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">Elf32_Off e_phoff;  <span class="comment">/* Program header table file offset */</span></span><br><span class="line">Elf32_Off e_shoff;  <span class="comment">/* Section header table file offset */</span></span><br><span class="line">Elf32_Word e_flags;  <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">Elf32_Half e_ehsize;  <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">Elf32_Half e_phentsize;  <span class="comment">/* Program header table entry size */</span></span><br><span class="line">Elf32_Half e_phnum;  <span class="comment">/* Program header table entry count */</span></span><br><span class="line">Elf32_Half e_shentsize;  <span class="comment">/* Section header table entry size */</span></span><br><span class="line">Elf32_Half e_shnum;  <span class="comment">/* Section header table entry count */</span></span><br><span class="line">Elf32_Half e_shstrndx;  <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p>上边是ELF头的格式，它定义了文件类型，机器架构，各种偏移等。</p><p>其中e_ident，前4个字节称为<code>魔数</code> ，对应的数值是固定的，后三个是E、L、F</p><p>其他还包括了文件位数，大小端版本等</p><p><strong>段与节</strong></p><p>ELF有三种格式：可执行文件，可重定位文件，共享目标文件</p><p>当文件为可重定位文件时，我们将中间部分称为节，这时在文件末尾的节头表相对更重要，它记录了所有节的信息；</p><p>当文件为另外两种类型时，我们将中间部分称为段，这时在文件头部的程序头表更为重要，它记录了所有段的信息。</p><p>总而言之，节与段只是在不同文件中表现形式的区别，实际上是同一部分内容。一般来说，段的数量会少于节，因为一个段一般会包含多个节的内容。</p><h3 id="2-printf处理"><a href="#2-printf处理" class="headerlink" title="2.printf处理"></a>2.printf处理</h3><p><strong>变长参数处理</strong></p><p>需要阅读指导书和c库，理解几个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">va_list   <span class="comment">//变长参数表的变量类型</span></span><br><span class="line">va_start  <span class="comment">//用于初始化变长参数表的宏</span></span><br><span class="line">va_arg    <span class="comment">//用于取变长参数表下一个参数的宏</span></span><br><span class="line">va_end    <span class="comment">//结束使用变长参数表的宏</span></span><br></pre></td></tr></table></figure><p><strong>理解控制台输出的本质</strong></p><p>想让控制台输出一个字符，实际上是对某一个内存地址写了一个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printcharc</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">......</span><br><span class="line">*((<span class="keyword">volatile</span> <span class="type">uint8_t</span> *)(KSEG1 + MALTA_SERIAL_DATA)) = ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-内核启动"><a href="#3-内核启动" class="headerlink" title="3.内核启动"></a>3.内核启动</h3><p><strong>QEMU启动流程</strong></p><p> MOS 操作系统的目标是在 QEMU 模拟器上运行，启动过程被大大简化了。QEMU 模拟器支持直接加载 ELF 格式的内核，也就是说，QEMU 已经提供了 bootloader 的引（启动）功能。MOS 操作系统不需要再实现 bootloader的功能。</p><p><strong>MIPS内核布局</strong></p><p>阅读<code>mmu.h</code> ，对放在内存的位置有了了解。kseg0， kseg1等更明确其功能</p><h2 id="实验心得与总结"><a href="#实验心得与总结" class="headerlink" title="实验心得与总结"></a>实验心得与总结</h2><p>本次实验难度中等，对于ELF的解析和printk的实现只要多阅读源代码，还是能比较顺利的解决的。</p><p>在课下看过C库对于边长参数的解析，还有printf的一些解析，限时测试的时候做的比较得心应手。</p><p>个人认为比较抽象的事在系统启动部分，linker的代码读的比较混乱。看了指导书和各种blog才理解讲的是什么。同时，为了理解整个系统的架构，而不是把他们当成割裂的部分完成实验，这就要求我对整体Makefile有所了解。</p>]]></content>
      
      
      <categories>
          
          <category> OSLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统启动 </tag>
            
            <tag> BIOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS2024-Lab0-实验报告</title>
      <link href="/2024/04/07/buaa-os2024-lab0-shi-yan-bao-gao/"/>
      <url>/2024/04/07/buaa-os2024-lab0-shi-yan-bao-gao/</url>
      
        <content type="html"><![CDATA[<h2 id="1-思考题"><a href="#1-思考题" class="headerlink" title="1.思考题"></a>1.思考题</h2><h3 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h3><blockquote><p>思考下列有关 Git 的问题：</p></blockquote><ul><li><p>在前述已初始化的 ~&#x2F;learnGit 目录下，创建一个名为 README.txt 的文件。执<br>行命令 git status &gt; Untracked.txt</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> README.txt <span class="comment">#创建文件</span></span><br><span class="line">git status &gt; Untracked.txt</span><br></pre></td></tr></table></figure></li><li><p>在 README.txt 文件中添加任意文件内容，然后使用 add 命令，再执行命令 git<br>status &gt; Stage.txt。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hell &gt; README.txt</span><br><span class="line">git add README.txt</span><br><span class="line">git status &gt; Stage.txt</span><br></pre></td></tr></table></figure></li><li><p>提交 README.txt，并在提交说明里写入自己的学号。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;22371218&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>执行命令 cat Untracked.txt 和 cat Stage.txt，对比两次运行的结果，体会<br>README.txt 两次所处位置的不同<br><strong>Untracked.txt内容</strong></p><blockquote><p>位于分支 master<br>未跟踪的文件:<br>（使用 “git add &lt;文件&gt;…” 以包含要提交的内容）<br>     README.txt<br>     Untracked.txt</p><p>提交为空，但是存在尚未跟踪的文件（使用 “git add” 建立跟踪）</p></blockquote><p><strong>Stage.txt内容</strong></p><blockquote><p>位于分支 master<br>要提交的变更：<br>（使用 “git restore –staged &lt;文件&gt;…” 以取消暂存）<br>     新文件：   README.txt</p><p>未跟踪的文件:<br>（使用 “git add &lt;文件&gt;…” 以包含要提交的内容）<br>     Stage.txt<br>     Untracked.txt</p></blockquote><p>一开始未跟踪README.txt，出于未跟踪状态。提交之后是Staged状态</p></li><li><p>修改 README.txt 文件，再执行命令 git status &gt; Modified.txt。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hhhhhhh &gt;&gt; README.txt</span><br><span class="line">git status &gt; Modified.txt</span><br></pre></td></tr></table></figure></li><li><p>执行命令 cat Modified.txt，观察其结果和第一次执行 add 命令之前的 status 是<br>否一样，并思考原因。<br><strong>Modified.txt内容</strong></p><blockquote><p>位于分支 master<br>尚未暂存以备提交的变更：<br>（使用 “git add &lt;文件&gt;…” 更新要提交的内容）<br>（使用 “git restore &lt;文件&gt;…” 丢弃工作区的改动）<br>     修改：     README.txt</p><p>未跟踪的文件:<br>（使用 “git add &lt;文件&gt;…” 以包含要提交的内容）<br>     Modified.txt<br>     Stage.txt<br>     Untracked.txt</p></blockquote><p>不一样。未执行add之前，README.txt是未跟踪状态。而add之后，出于Staged状态。然后进行了commit，文件是UnModified状态。然后是再次修改文件，文件编程Modified状态</p></li></ul><h3 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h3><blockquote><p>仔细看看0.10，思考一下箭头中的 add the file 、stage the file 和commit 分别对应的是 Git 里的哪些命令呢？</p></blockquote><p>add the file：对应的是<code>git add</code> 命令。将未追踪文件添加追踪并添加到暂存区</p><p>stage the file：对应的还是<code>git add</code> 命令，当文件有改动时，依旧可以通过git add将这个改动文件变更到staged状态</p><p>commit：对应的是<code>git commit</code> 命令，提交文件，文件变成Unmodified</p><h3 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h3><blockquote><p>思考下列问题：</p></blockquote><ol><li><p>代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- print.c</span><br></pre></td></tr></table></figure></li><li><p>代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当<br>使用什么命令将其恢复？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD print.c</span><br><span class="line">gitcheckout-- print.c</span><br></pre></td></tr></table></figure></li><li><p>如果无关文件 <code>hello.txt</code> 已经被添加到暂存区，但不想删除此文件的前提下将其移出暂存区，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached hello.txt</span><br></pre></td></tr></table></figure></li></ol><h3 id="Thinking0-4"><a href="#Thinking0-4" class="headerlink" title="Thinking0.4"></a>Thinking0.4</h3><blockquote><p>思考下列有关 Git 的问题：</p></blockquote><ul><li><p>找到在 &#x2F;home&#x2F;22xxxxxx&#x2F;learnGit 下刚刚创建的 README.txt 文件，若不存<br>在则新建该文件</p></li><li><p>在文件里加入 Testing 1，git add，git commit，提交说明记为 1</p></li><li><p>模仿上述做法，把 1 分别改为 2 和 3，再提交两次</p></li><li><p>使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为3 的哈希值。</p></li></ul><blockquote><p>commit 15a9a39500dd07fac643e60c7ac70a43b3c6872a (HEAD -&gt; master)<br>Author:<br>Date:   Mon Mar 11 11:14:13 2024 +0800<br>3<br>commit 36373862ade2ef0d5ae0daaa0a8134c4a20c06a0<br>Author:<br>Date:   Mon Mar 11 11:13:52 2024 +0800<br>2<br>commit 67caf92e60a6612b92e652f74e51763a331fdcfd<br>Author:<br>Date:   Mon Mar 11 11:13:27 2024 +0800<br>1</p></blockquote><p>确实有三次提交</p><blockquote><p>进行版本回退。执行命令 git reset –hard HEAD^ 后，再执行 git log，观<br>察其变化。</p></blockquote><p>log日志中没有了提交信息为3的记录</p><blockquote><p>找到提交说明为 1 的哈希值，执行命令 git reset –hard <hash> 后，再执<br>行 git log，观察其变化。</p></blockquote><p>此时commit2 和commit3都没有了，只有commit1</p><blockquote><p>现在已经回到了旧版本，为了再次回到新版本，执行 git reset –hard <hash>，再执行 git log，观察其变化。</p></blockquote><p>hash用commit3的哈希值，git log之后 commit1,2,3都在</p><h3 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h3><blockquote><p>执行如下命令, 并查看结果</p></blockquote><blockquote><p>echo first</p></blockquote><p>fiest</p><blockquote><p>echo second &gt; output.txt</p></blockquote><p>终端上无输出，output.txt文件中有”secend”</p><blockquote><p>echo third &gt; output.txt</p></blockquote><p>终端上无输出，output.txt原文件被覆盖为”third”</p><blockquote><p>echo forth &gt;&gt; output.txt</p></blockquote><p>终端上无输出，”forth”追加到output.txt文件</p><h3 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h3><blockquote><p>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），将创建该文件的命令序列保存在 command 文件中，并将 test 文件作为批处理文件运行，将运行结果输出至 result 文件中。给出 command 文件和 result 文件的内容，并对最后的结果进行解释说明（可以从 test 文件的内容入手）. 具体实现的过程中思考下列问题: echo echo Shell Start 与 echo <code>echo Shell Start</code> 效果是否有区别; echo echo $c&gt;file1与 echo <code>echo $c&gt;file1</code> 效果是否有区别.</p></blockquote><p>command内容</p><img src="1.png" style="zoom:50%" /><p>result内容</p><p><img src="/2024/04/07/buaa-os2024-lab0-shi-yan-bao-gao/2.png"></p><p>第3行定义变量a&#x3D;1，第5行定义b&#x3D;2，第7行定义c&#x3D;a+b&#x3D;3</p><p>echo $c&gt;file1使得file1内容是3，echo $b&gt;file2 使得file2内容是2,echo $a&gt;file3使得file3内容是1</p><p>然后同过三个cat命令使得file4内容是3 2 1</p><p>最后<code>cat file4&gt;&gt;result</code> 使得result是3 2 1</p><p>echo echo Shell Start 输出<code>echo Shell Start</code></p><p>带&#96;的输出Shell Start</p><p>echo echo $c&gt;file1会在file1文件中写入echo</p><p>另一个没有</p><h2 id="2-难点分析"><a href="#2-难点分析" class="headerlink" title="2.难点分析"></a>2.难点分析</h2><h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p>  . 表示当前目录 </p><p>  ..表示上级目录</p><h3 id="chmod-和文件权限"><a href="#chmod-和文件权限" class="headerlink" title="chmod 和文件权限"></a><code>chmod</code> 和文件权限</h3><p>  -rwxrwxrwx 权限对应二进制数</p><p>  通过chmod可以改变文件权限</p><h3 id="git-相关"><a href="#git-相关" class="headerlink" title="git 相关"></a>git 相关</h3><p>  通过git add追踪，git commit 提交等等</p><p>  相关版本回退</p><p>  <img src="/2024/04/07/buaa-os2024-lab0-shi-yan-bao-gao/3.png"></p><h3 id="grep-sed-awk-管道的综合应用"><a href="#grep-sed-awk-管道的综合应用" class="headerlink" title="grep sed awk 管道的综合应用"></a>grep sed awk 管道的综合应用</h3><p>  在extra的搜寻ppid的实验</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> [ ! -z <span class="variable">$PID</span> ]; <span class="keyword">then</span></span><br><span class="line"> <span class="comment"># Your code here. (3/3)</span></span><br><span class="line"> line=`awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> <span class="variable">$FILE</span> | grep -E <span class="string">&quot;\&lt;<span class="variable">$PID</span>\&gt;&quot;</span> -n | awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line"> nowpid=`sed <span class="string">&quot;<span class="variable">$line</span> p&quot;</span> -n <span class="variable">$FILE</span>  | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line"> fpid=`sed <span class="string">&quot;<span class="variable">$line</span> p&quot;</span>  -n <span class="variable">$FILE</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>` </span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$fpid</span></span><br><span class="line"> <span class="keyword">while</span> [ <span class="variable">$fpid</span>  -gt  0  ]</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    line=`awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> <span class="variable">$FILE</span> | grep <span class="string">&quot;\&lt;<span class="variable">$fpid</span>\&gt;&quot;</span> -n | awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line">    nowpid=`sed <span class="string">&quot;<span class="variable">$line</span> p&quot;</span> -n <span class="variable">$FILE</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line">    fpid=`sed <span class="string">&quot;<span class="variable">$line</span> p&quot;</span>  -n <span class="variable">$FILE</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$fpid</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   三个文本处理工具配合管道，找到自己进程的行号，再通过行号找到父进程，然后不断循环找到pid为0的进程</p><p>   其中需要注意用<code>grep -E</code> 配合正则表达式限定搜索进程号，注意<code>awk</code> 单独输出pid或者ppid的那一列，通过<code>sed</code> 输出对应行号</p><h3 id="shell脚本编写"><a href="#shell脚本编写" class="headerlink" title="shell脚本编写"></a>shell脚本编写</h3><p>  变量定义“&#x3D;”左右不能有空格[] </p><p>  条件判断有空格</p><p>  if while的语法学习</p><h3 id="通配符使用"><a href="#通配符使用" class="headerlink" title="通配符使用"></a>通配符使用</h3><p>  通过<code>*.c</code>或<code>*.o</code> 查找目录下的所有相关文件</p><h2 id="3-实验体会"><a href="#3-实验体会" class="headerlink" title="3.实验体会"></a>3.实验体会</h2><p>Lab0实验比较简单，但是细碎的内容比较多。shell脚本的语法类似c语言但是在格式上有很多自己的特性，需要特别记忆。Makefile的书写在Lab0考的比较简单，但是在网上看视频有很多进阶用法，学的时候记了很多没用上。grep sed awk的配合上管道处理文本很强大，语法细节也很多。</p><p>总的来说，由于上学期选修了系统编程课程，对Linux的相关操作有所了解，做起来比较得心应手。</p>]]></content>
      
      
      <categories>
          
          <category> OSLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> git </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
