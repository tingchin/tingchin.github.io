{"meta":{"title":"JiachunH's Blog","subtitle":"JiachunH's Blog","description":"","author":"HJC","url":"https://tingchin.github.io","root":"/"},"pages":[{"title":"404","date":"2024-04-06T09:25:30.000Z","updated":"2024-04-06T13:53:23.682Z","comments":true,"path":"404.html","permalink":"https://tingchin.github.io/404","excerpt":"","text":""},{"title":"categories","date":"2024-04-06T13:49:07.000Z","updated":"2024-04-06T13:49:48.538Z","comments":true,"path":"categories/index.html","permalink":"https://tingchin.github.io/categories/","excerpt":"","text":""},{"title":"about","date":"2024-04-06T13:51:17.000Z","updated":"2024-04-06T13:51:32.128Z","comments":true,"path":"about/index.html","permalink":"https://tingchin.github.io/about/","excerpt":"","text":""},{"title":"link","date":"2024-04-07T03:45:48.000Z","updated":"2024-04-07T03:46:06.993Z","comments":true,"path":"link/index.html","permalink":"https://tingchin.github.io/link/","excerpt":"","text":""},{"title":"tags","date":"2024-04-06T13:50:14.000Z","updated":"2024-04-07T03:45:08.950Z","comments":true,"path":"tags/index.html","permalink":"https://tingchin.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"BUAA-OS2024-Lab1-实验报告","slug":"BUAA-OS2024-Lab1-实验报告","date":"2024-04-07T09:44:36.000Z","updated":"2024-04-07T09:49:47.867Z","comments":true,"path":"2024/04/07/buaa-os2024-lab1-shi-yan-bao-gao/","permalink":"https://tingchin.github.io/2024/04/07/buaa-os2024-lab1-shi-yan-bao-gao/","excerpt":"","text":"思考题Thinking 1.1 请阅读 附录中的编译链接详解，尝试分别使用实验环境中的原生 x86 工具链（gcc、ld、readelf、objdump 等）和 MIPS 交叉编译工具链（带有 mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。 123456789gcc -c hello.c # 原生X86生成.o文件gcc hello.o # 原生x86链接readelf -h hello.o # 读elf文件头objdump -DS hello.o &gt; h.txt # 反汇编mips-linux-gnu-gcc -c hello.c # 生成.o文件mips-linux-gnu-gcc hello.o # 链接mips-linux-gnu-readelf -h hello.o # 读elf文件头mips-linux-gnu-objdump -DS hello.o &gt; h.txt # 反汇编 两种工具的一些区别 原生x86汇编的是elf64文件 交叉汇编的是elf32文件 原生x86汇编的是小端文件，交叉汇编的是大端文件 两边反汇编出来的源码分别是X86和MIPS的源码 一些特点 .o文件时，调用函数地址为0 生成可执行文件后，才能重定位，找到正确的地址 objdump参数含义： -D 反汇编所有section的信息 -S 尽可能反汇编出源代码 Thinking 1.2 思考下述问题： 尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文件。 也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚才介绍的系&gt;统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf-h，并阅读 tools&#x2F;readelf 目录下的 Makefile，观察 readelf 与 hello 的不同） 123456789101112131415161718git@22371218:~/22371218/target (lab1)$ ~/22371218/tools/readelf/readelf mos0:0x01:0x800200002:0x800218d03:0x800218e84:0x800219005:0x06:0x07:0x08:0x09:0x010:0x011:0x012:0x013:0x014:0x015:0x016:0x0 我们定义的ELF 格式是32位，也就是说，我们自己编写的readelf 程序只能阅读32位的ELF文件。 通过readelf -h hello 和readelf -h mos ，发现他们都是ELf32的文件，因此可以用我们编写的readelf阅读。而我们编写的readelf 是ELF64的文件，是64位的，所以无法解析。 观察readelf目录下的Makefile文件，可以知道，我们的readelf是$(CC) $^ -o $@编译的64位文件，而hello 是通过 $(CC) $^ -o $@ -m32 -static -g 编译的，通过-m32 参数生成的是32位文件。 Thinking 1.3 在理论课上我们了解到，MIPS 体系结构上电时，启动入口地0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？ 我们的mos是运行在在QEMU上的。QEMU已经提供了bootloader功能，第一步已经完成了。只需要将内核加载后跳转到内核函数入口就可以启动完毕。 在链接器中，我们指定了内核加载的地址，并通过start中的代码，初始化硬件设备，设置堆栈入口，然后跳转到了内核函数入口处。 实验难点1.ELF文件解析 ELF文件有五个部分：ELF头，段头表，节头表，段表项，节表项 ELF头 12345678910111213141516typedef struct &#123; unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type; /* Object file type */ Elf32_Half e_machine; /* Architecture */ Elf32_Word e_version; /* Object file version */ Elf32_Addr e_entry; /* Entry point virtual address */ Elf32_Off e_phoff; /* Program header table file offset */ Elf32_Off e_shoff; /* Section header table file offset */ Elf32_Word e_flags; /* Processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf32_Half e_phentsize; /* Program header table entry size */ Elf32_Half e_phnum; /* Program header table entry count */ Elf32_Half e_shentsize; /* Section header table entry size */ Elf32_Half e_shnum; /* Section header table entry count */ Elf32_Half e_shstrndx; /* Section header string table index */&#125; Elf32_Ehdr; 上边是ELF头的格式，它定义了文件类型，机器架构，各种偏移等。 其中e_ident，前4个字节称为魔数 ，对应的数值是固定的，后三个是E、L、F 其他还包括了文件位数，大小端版本等 段与节 ELF有三种格式：可执行文件，可重定位文件，共享目标文件 当文件为可重定位文件时，我们将中间部分称为节，这时在文件末尾的节头表相对更重要，它记录了所有节的信息； 当文件为另外两种类型时，我们将中间部分称为段，这时在文件头部的程序头表更为重要，它记录了所有段的信息。 总而言之，节与段只是在不同文件中表现形式的区别，实际上是同一部分内容。一般来说，段的数量会少于节，因为一个段一般会包含多个节的内容。 2.printf处理变长参数处理 需要阅读指导书和c库，理解几个宏 1234va_list //变长参数表的变量类型va_start //用于初始化变长参数表的宏va_arg //用于取变长参数表下一个参数的宏va_end //结束使用变长参数表的宏 理解控制台输出的本质 想让控制台输出一个字符，实际上是对某一个内存地址写了一个字节。 1234void printcharc(char ch) &#123;......*((volatile uint8_t *)(KSEG1 + MALTA_SERIAL_DATA)) = ch;&#125; 3.内核启动QEMU启动流程 MOS 操作系统的目标是在 QEMU 模拟器上运行，启动过程被大大简化了。QEMU 模拟器支持直接加载 ELF 格式的内核，也就是说，QEMU 已经提供了 bootloader 的引（启动）功能。MOS 操作系统不需要再实现 bootloader的功能。 MIPS内核布局 阅读mmu.h ，对放在内存的位置有了了解。kseg0， kseg1等更明确其功能 实验心得与总结本次实验难度中等，对于ELF的解析和printk的实现只要多阅读源代码，还是能比较顺利的解决的。 在课下看过C库对于边长参数的解析，还有printf的一些解析，限时测试的时候做的比较得心应手。 个人认为比较抽象的事在系统启动部分，linker的代码读的比较混乱。看了指导书和各种blog才理解讲的是什么。同时，为了理解整个系统的架构，而不是把他们当成割裂的部分完成实验，这就要求我对整体Makefile有所了解。","categories":[{"name":"OSLab","slug":"OSLab","permalink":"https://tingchin.github.io/categories/OSLab/"}],"tags":[{"name":"系统启动","slug":"系统启动","permalink":"https://tingchin.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"},{"name":"BIOS","slug":"BIOS","permalink":"https://tingchin.github.io/tags/BIOS/"}]},{"title":"BUAA-OS2024-Lab0-实验报告","slug":"BUAA-OS2024-Lab0-实验报告","date":"2024-04-06T16:28:08.000Z","updated":"2024-04-07T09:54:41.542Z","comments":true,"path":"2024/04/07/buaa-os2024-lab0-shi-yan-bao-gao/","permalink":"https://tingchin.github.io/2024/04/07/buaa-os2024-lab0-shi-yan-bao-gao/","excerpt":"","text":"1.思考题Thinking 0.1 思考下列有关 Git 的问题： 在前述已初始化的 ~&#x2F;learnGit 目录下，创建一个名为 README.txt 的文件。执行命令 git status &gt; Untracked.txt 12touch README.txt #创建文件git status &gt; Untracked.txt 在 README.txt 文件中添加任意文件内容，然后使用 add 命令，再执行命令 gitstatus &gt; Stage.txt。 123echo hell &gt; README.txtgit add README.txtgit status &gt; Stage.txt 提交 README.txt，并在提交说明里写入自己的学号。 1git commit -m &quot;22371218&quot; 执行命令 cat Untracked.txt 和 cat Stage.txt，对比两次运行的结果，体会README.txt 两次所处位置的不同Untracked.txt内容 位于分支 master未跟踪的文件:（使用 “git add &lt;文件&gt;…” 以包含要提交的内容） README.txt Untracked.txt 提交为空，但是存在尚未跟踪的文件（使用 “git add” 建立跟踪） Stage.txt内容 位于分支 master要提交的变更：（使用 “git restore –staged &lt;文件&gt;…” 以取消暂存） 新文件： README.txt 未跟踪的文件:（使用 “git add &lt;文件&gt;…” 以包含要提交的内容） Stage.txt Untracked.txt 一开始未跟踪README.txt，出于未跟踪状态。提交之后是Staged状态 修改 README.txt 文件，再执行命令 git status &gt; Modified.txt。 12echo hhhhhhh &gt;&gt; README.txtgit status &gt; Modified.txt 执行命令 cat Modified.txt，观察其结果和第一次执行 add 命令之前的 status 是否一样，并思考原因。Modified.txt内容 位于分支 master尚未暂存以备提交的变更：（使用 “git add &lt;文件&gt;…” 更新要提交的内容）（使用 “git restore &lt;文件&gt;…” 丢弃工作区的改动） 修改： README.txt 未跟踪的文件:（使用 “git add &lt;文件&gt;…” 以包含要提交的内容） Modified.txt Stage.txt Untracked.txt 不一样。未执行add之前，README.txt是未跟踪状态。而add之后，出于Staged状态。然后进行了commit，文件是UnModified状态。然后是再次修改文件，文件编程Modified状态 Thinking 0.2 仔细看看0.10，思考一下箭头中的 add the file 、stage the file 和commit 分别对应的是 Git 里的哪些命令呢？ add the file：对应的是git add 命令。将未追踪文件添加追踪并添加到暂存区 stage the file：对应的还是git add 命令，当文件有改动时，依旧可以通过git add将这个改动文件变更到staged状态 commit：对应的是git commit 命令，提交文件，文件变成Unmodified Thinking 0.3 思考下列问题： 代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？ 1git checkout -- print.c 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当使用什么命令将其恢复？ 12git reset HEAD print.cgitcheckout-- print.c 如果无关文件 hello.txt 已经被添加到暂存区，但不想删除此文件的前提下将其移出暂存区， 1git rm --cached hello.txt Thinking0.4 思考下列有关 Git 的问题： 找到在 &#x2F;home&#x2F;22xxxxxx&#x2F;learnGit 下刚刚创建的 README.txt 文件，若不存在则新建该文件 在文件里加入 Testing 1，git add，git commit，提交说明记为 1 模仿上述做法，把 1 分别改为 2 和 3，再提交两次 使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为3 的哈希值。 commit 15a9a39500dd07fac643e60c7ac70a43b3c6872a (HEAD -&gt; master)Author:Date: Mon Mar 11 11:14:13 2024 +08003commit 36373862ade2ef0d5ae0daaa0a8134c4a20c06a0Author:Date: Mon Mar 11 11:13:52 2024 +08002commit 67caf92e60a6612b92e652f74e51763a331fdcfdAuthor:Date: Mon Mar 11 11:13:27 2024 +08001 确实有三次提交 进行版本回退。执行命令 git reset –hard HEAD^ 后，再执行 git log，观察其变化。 log日志中没有了提交信息为3的记录 找到提交说明为 1 的哈希值，执行命令 git reset –hard 后，再执行 git log，观察其变化。 此时commit2 和commit3都没有了，只有commit1 现在已经回到了旧版本，为了再次回到新版本，执行 git reset –hard ，再执行 git log，观察其变化。 hash用commit3的哈希值，git log之后 commit1,2,3都在 Thinking 0.5 执行如下命令, 并查看结果 echo first fiest echo second &gt; output.txt 终端上无输出，output.txt文件中有”secend” echo third &gt; output.txt 终端上无输出，output.txt原文件被覆盖为”third” echo forth &gt;&gt; output.txt 终端上无输出，”forth”追加到output.txt文件 Thinking 0.6 使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），将创建该文件的命令序列保存在 command 文件中，并将 test 文件作为批处理文件运行，将运行结果输出至 result 文件中。给出 command 文件和 result 文件的内容，并对最后的结果进行解释说明（可以从 test 文件的内容入手）. 具体实现的过程中思考下列问题: echo echo Shell Start 与 echo echo Shell Start 效果是否有区别; echo echo $c&gt;file1与 echo echo $c&gt;file1 效果是否有区别. command内容 result内容 第3行定义变量a&#x3D;1，第5行定义b&#x3D;2，第7行定义c&#x3D;a+b&#x3D;3 echo $c&gt;file1使得file1内容是3，echo $b&gt;file2 使得file2内容是2,echo $a&gt;file3使得file3内容是1 然后同过三个cat命令使得file4内容是3 2 1 最后cat file4&gt;&gt;result 使得result是3 2 1 echo echo Shell Start 输出echo Shell Start 带&#96;的输出Shell Start echo echo $c&gt;file1会在file1文件中写入echo 另一个没有 2.难点分析路径问题 . 表示当前目录 ..表示上级目录 chmod 和文件权限 -rwxrwxrwx 权限对应二进制数 通过chmod可以改变文件权限 git 相关 通过git add追踪，git commit 提交等等 相关版本回退 grep sed awk 管道的综合应用 在extra的搜寻ppid的实验 12345678910111213141516elif [ ! -z $PID ]; then # Your code here. (3/3) line=`awk &#x27;&#123;print $2&#125;&#x27; $FILE | grep -E &quot;\\&lt;$PID\\&gt;&quot; -n | awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27;` nowpid=`sed &quot;$line p&quot; -n $FILE | awk &#x27;&#123;print $2&#125;&#x27;` fpid=`sed &quot;$line p&quot; -n $FILE | awk &#x27;&#123;print $3&#125;&#x27;` echo $fpid while [ $fpid -gt 0 ] do line=`awk &#x27;&#123;print $2&#125;&#x27; $FILE | grep &quot;\\&lt;$fpid\\&gt;&quot; -n | awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27;` nowpid=`sed &quot;$line p&quot; -n $FILE | awk &#x27;&#123;print $2&#125;&#x27;` fpid=`sed &quot;$line p&quot; -n $FILE | awk &#x27;&#123;print $3&#125;&#x27;` echo $fpid doneelse 三个文本处理工具配合管道，找到自己进程的行号，再通过行号找到父进程，然后不断循环找到pid为0的进程 其中需要注意用grep -E 配合正则表达式限定搜索进程号，注意awk 单独输出pid或者ppid的那一列，通过sed 输出对应行号 shell脚本编写 变量定义“&#x3D;”左右不能有空格[] 条件判断有空格 if while的语法学习 通配符使用 通过*.c或*.o 查找目录下的所有相关文件 3.实验体会Lab0实验比较简单，但是细碎的内容比较多。shell脚本的语法类似c语言但是在格式上有很多自己的特性，需要特别记忆。Makefile的书写在Lab0考的比较简单，但是在网上看视频有很多进阶用法，学的时候记了很多没用上。grep sed awk的配合上管道处理文本很强大，语法细节也很多。 总的来说，由于上学期选修了系统编程课程，对Linux的相关操作有所了解，做起来比较得心应手。","categories":[{"name":"OSLab","slug":"OSLab","permalink":"https://tingchin.github.io/categories/OSLab/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://tingchin.github.io/tags/linux/"},{"name":"git","slug":"git","permalink":"https://tingchin.github.io/tags/git/"},{"name":"shell","slug":"shell","permalink":"https://tingchin.github.io/tags/shell/"}]}],"categories":[{"name":"OSLab","slug":"OSLab","permalink":"https://tingchin.github.io/categories/OSLab/"}],"tags":[{"name":"系统启动","slug":"系统启动","permalink":"https://tingchin.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/"},{"name":"BIOS","slug":"BIOS","permalink":"https://tingchin.github.io/tags/BIOS/"},{"name":"linux","slug":"linux","permalink":"https://tingchin.github.io/tags/linux/"},{"name":"git","slug":"git","permalink":"https://tingchin.github.io/tags/git/"},{"name":"shell","slug":"shell","permalink":"https://tingchin.github.io/tags/shell/"}]}